---
import Layout from '../layouts/Layout.astro';

const posts = [
	{
		title: "AI Mode guardrails: Search & PMax",
		description: "Cum documentăm și aplicăm guardrails pentru AI Mode în Google Ads.",
		url: "/blog/google-ads-ai-mode-guardrails",
		tag: "Google Ads",
		date: "16 Februarie 2026"
	},
	{
		title: "Advantage+ Data Residency",
		description: "Setările Meta care păstrează datele în UE + Creative Clusters pentru ROA.",
		url: "/blog/meta-advantage-plus-data-residency",
		tag: "Meta",
		date: "16 Februarie 2026"
	},
	{
		title: "Conversational Campaign Builder",
		description: "Builder-ul AI pentru Search și cum îl folosim în briefurile ROA.",
		url: "/blog/google-ads-conversational-campaign-builder",
		tag: "Search",
		date: "16 Februarie 2026"
	},
	{
		title: "Creative Intelligence în PMax",
		description: "Dashboard-ul AI care măsoară contribuția fiecărui asset.",
		url: "/blog/performance-max-creative-intelligence",
		tag: "Performance Max",
		date: "16 Februarie 2026"
	},
	{
		title: "Playbook AI pentru bugete PPC",
		description: "Cum mutăm bugetele între Search, PMax și Meta folosind ROAS marginal.",
		url: "/blog/ppc-ai-budget-playbooks",
		tag: "Strategie",
		date: "16 Februarie 2026"
	},
	{
		title: "ROAS automat pentru clienți noi",
		description: "Google calculează singur conversion value-ul pentru campaniile NCA.",
		url: "/blog/google-ads-roas-new-customers",
		tag: "Acquisition",
		date: "16 Februarie 2026"
	},
	{
		title: "Reclame în ChatGPT: trust & AI agents",
		description: "Ce reguli impune OpenAI și cum pregătim campanii conversaționale.",
		url: "/blog/chatgpt-ads-trust-framework",
		tag: "AI Ads",
		date: "16 Februarie 2026"
	},
	{
		title: "Meta Premium & Manus AI",
		description: "Abonamentele plătite schimbă reach-ul, privacy-ul și conținutul.",
		url: "/blog/meta-premium-subscriptions-ai",
		tag: "Social",
		date: "16 Februarie 2026"
	},
	{
		title: "Recommended Experiments în Google Ads",
		description: "Teste preconfigurate direct în Experiments dashboard.",
		url: "/blog/google-ads-recommended-experiments",
		tag: "Testing",
		date: "16 Februarie 2026"
	},
	{
		title: "Google 2026: Era Comerțului Agentic",
		description: "Analiză detaliată a costurilor CPC pe Google, Meta și TikTok cu predicții pentru 2026.",
		url: "/blog/ppc-performance-analysis-2024-2026",
		tag: "Data",
		date: "15 Februarie 2026"
	},
	{
		title: "Revoluția PPC în 2026: ChatGPT Ads și Era Intent-ului",
		description: "Cum OpenAI și Google schimbă regulile jocului prin reclame conversaționale.",
		url: "/blog/ppc-revolution-2026",
		tag: "Analiză",
		date: "15 Februarie 2026"
	},
	{
		title: "Google Ads 2026: Strategii în Recesiune",
		description: "Cum să muți focusul pe Profit-First Bidding când piața se contractă.",
		url: "/blog/google-ads-2026-recesiune",
		tag: "Strategie",
		date: "14 Februarie 2026"
	},
	{
		title: "AdTech 2026: Revoluția First-Party Data",
		description: "Ghid tehnic despre Server-Side Tracking și supraviețuirea fără cookies.",
		url: "/blog/adtech-2026-tracking",
		tag: "Tehnologie",
		date: "14 Februarie 2026"
	}
];

const categories = ['Toate', ...new Set(posts.map(post => post.tag))];
---

<Layout title="Roa Marketing — Știri & Analize">
	<div class="container mx-auto px-6 py-16">
		<section class="text-center space-y-6 mb-12">
			<p class="text-sm uppercase tracking-[0.4em] text-cyan-300 font-bold">Insights zilnice</p>
			<h1 class="text-4xl md:text-6xl font-black leading-tight">Știri, analize și tactici pentru PPC în era agentică.</h1>
			<p class="text-lg text-slate-400 max-w-3xl mx-auto">Filtrează după categorie sau caută în timp real ideile care te interesează. Tot conținutul este produs de swarm-ul nostru specializat pe marketing de performanță.</p>
		</section>

		<section class="sticky top-24 z-10 bg-slate-950/80 backdrop-blur-xl border border-white/10 rounded-3xl p-6 mb-10 shadow-2xl">
			<div class="mb-4 md:hidden">
				<label for="categorySelect" class="text-xs uppercase tracking-[0.3em] text-slate-400 font-bold mb-2 block">Filtrează după categorie</label>
				<div class="relative">
					<select id="categorySelect" class="w-full bg-white/5 border border-white/10 rounded-2xl px-4 py-3 text-sm text-white focus:border-cyan-400 focus:outline-none appearance-none">
						{categories.map(category => (
							<option value={category}>{category}</option>
						))}
					</select>
					<span class="pointer-events-none absolute right-4 top-1/2 -translate-y-1/2 text-slate-500 text-xs">▼</span>
				</div>
			</div>
			<div class="hidden md:flex md:flex-wrap items-center gap-3 mb-4">
				{categories.map(category => (
					<button
						type="button"
						class="category-pill px-4 py-2 rounded-full border border-white/10 text-sm font-semibold text-slate-300 hover:border-cyan-400 hover:text-white transition-all"
						data-category-btn
						data-category={category}
					>
						{category}
					</button>
				))}
			</div>
			<div class="relative">
				<input id="postSearch" type="search" placeholder="Caută după titlu, categorie sau cuvinte cheie" class="w-full bg-white/5 border border-white/10 rounded-2xl px-5 py-3 text-base focus:border-cyan-400 focus:outline-none placeholder:text-slate-500" />
				<span class="absolute right-5 top-1/2 -translate-y-1/2 text-slate-500 text-sm">⌘K</span>
			</div>
		</section>

		<section class="py-4">
			<h2 class="sr-only">Ultimele articole</h2>
			<div class="grid grid-cols-1 md:grid-cols-2 gap-8" id="postsGrid">
				{posts.map(post => (
					<a
						href={post.url}
						class="post-card group border border-white/10 rounded-3xl p-6 hover:border-cyan-500 transition-all bg-white/5"
						data-post-card
						data-category={post.tag}
						data-search={`${post.title.toLowerCase()} ${post.description.toLowerCase()} ${post.tag.toLowerCase()}`}
					>
						<div class="flex items-center justify-between mb-4">
							<span class="text-cyan-400 text-xs font-bold uppercase tracking-[0.3em]">{post.tag}</span>
							<small class="text-xs text-slate-500">{post.date}</small>
						</div>
						<h3 class="text-2xl font-bold mb-3 group-hover:text-cyan-300 transition-colors">{post.title}</h3>
						<p class="text-slate-400 text-base">{post.description}</p>
					</a>
				))}
			</div>
			<div id="emptyState" class="hidden text-center py-16 border border-dashed border-white/10 rounded-3xl mt-6">
				<p class="text-slate-400">Nu am găsit articole pentru filtrul căutat. Încearcă alt cuvânt sau resetează categoriile.</p>
			</div>
		</section>
	</div>

	<script is:inline>
		const buttons = document.querySelectorAll('[data-category-btn]');
		const cards = document.querySelectorAll('[data-post-card]');
		const searchInput = document.querySelector('#postSearch');
		const emptyState = document.querySelector('#emptyState');
		const categorySelect = document.querySelector('#categorySelect');
		let activeCategory = 'Toate';

		const normalize = (value) => value.toLowerCase().trim();

		const setActiveCategory = (category) => {
			activeCategory = category;
			buttons.forEach(btn => {
				btn.classList.toggle('bg-cyan-500/20', btn.dataset.category === category);
				btn.classList.toggle('text-white', btn.dataset.category === category);
			});
			if (categorySelect && categorySelect.value !== category) {
				categorySelect.value = category;
			}
			filterCards();
		};

		const filterCards = () => {
			const query = normalize(searchInput.value || '');
			let hasVisible = false;

			cards.forEach(card => {
				const category = card.dataset.category;
				const searchable = card.dataset.search;
				const matchCategory = activeCategory === 'Toate' || category === activeCategory;
				const matchQuery = searchable.includes(query);
				const shouldShow = matchCategory && matchQuery;
				card.classList.toggle('hidden', !shouldShow);
				if (shouldShow) {
					hasVisible = true;
				}
			});

			emptyState.classList.toggle('hidden', hasVisible);
		};

		buttons.forEach(button => {
			if (button.dataset.category === 'Toate') {
				button.classList.add('bg-cyan-500/20', 'text-white');
			}

			button.addEventListener('click', () => {
				setActiveCategory(button.dataset.category);
			});
		});

		if (categorySelect) {
			categorySelect.value = activeCategory;
			categorySelect.addEventListener('change', (event) => {
				setActiveCategory(event.target.value);
			});
		}

		searchInput.addEventListener('input', filterCards);
		filterCards();
	</script>
</Layout>
